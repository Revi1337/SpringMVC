
1. jakarta.validation(표준 검증기) vs org.hibernate.validator(하이버네이트 검증기) 차이
--> jakarta.validation 특정 구현체에 관계없이 제공되는 인터페이스이고,
    org.hibernate.validator 로 시작하면 하이버네이트 validator 구현체를 사용할때만 제공되는 검증 기능.
    대부분 하이버네이트 validator 를 사용하므로 자유롭게 사용해도 된다.

    --> 피키지가 jakarta.validation 로 시작하는 어노테이션들
        --> 자바 표준 검증기, 하이버네이트 검증기 모두 동작한다.
        --> Ex. @NotNull, @NotBlank 등등

    --> 피키지가 org.hibernate.validator 로 시작하는 어노테이션들
        --> 하이버네이트 검증기에서만 동작한다.
        --> Ex. @Range 등등


2. 검증 어노테이션
@NotBlank : 빈값 + 공백만 있는 경우를 허용하지 않는다.
@NotNull : null 을 허용하지 않는다.
@Range(min = 1000, max = 1000000) : 범위 안의 값이어야 한다.
@Max(9999) : 최대 9999 까지만 허용한다.


3. Spring Boot 는 자동으로 글로벌 Validator 를 등록한다.
--> Spring Boot 는 LocalValidatorFactoryBean 을 Global Validator 로 등록한다.
    이 Validator 는 @NotNull 같은 어노테이션을 보고 검증을 수행한다.
    이렇게 글로벌 Validator 가 적용되어 있기 때문에, @Valid, @Validated 만 적용하면 된다.
    검증 오류가 발생하면, FieldError, ObjectError 를 생성해서 BindingResult 에 담아준다.
--> 주의할 것은 직접 Global Validator 를 만들어서 등록하면
    Spring Boot 는 BeanValidator(LocalValidatorFactoryBean) 를 Global Validator 로 등록하지 않는다.
    따라서 어노테이션 기반의 빈 검증기가 동작하지 않는다. (따라서 BeanValidator 를 사용하려면 직접 등록한 Global Validator 를 제거해야 한다.)


4. 검증시 @Valid, @Validated 둘 중 무엇을 사용?
 --> jakarta.validation.@Valid 를 사용하려면 org.springframework.boot:spring-boot-starter-validation 를 추가해야 사용가능
     (자바 표준 검증 어노테이션)
 --> @Validated 는 스프링 전용 검증 어노테이션. @Validated 는 내부에 groups 라는 기능을 포함하고 있음.


5. 검증 순서
    1. @ModelAttribute 각각의 필드에 타입 변환 시도
        --> 성공하면 다음으로
        --> 실패하면 typeMismatch 로 FieldError 추가
    2. Validator 적용

    요약: 바인딩에 성공한 필드만 Bean Validation 적용
    예: itemName 에 문자 A 입력 --> 타입 변환 성공 -> itemName 필드에 BeanValidation 적용
        price 에 문자 A 입력 --> "A" 를 숫자 타입 변환 시도 실패 --> typeMismatch FiledError 추가 --> price 필드는 BeanValidation 적용 X


6. Bean Validation 메시지화 Arguments
--> Bean Validation 을 {name}.properties 에 메시지화할 때 Arguments 들의 순서가 있음.
    {0} 는 field 이름(오류가 난 필드이름). 나머지 {2}, {1} 은 속성의 알파벳 순. 만약 @Range 의 max 와 min 속성이 있으면 max 가 {1}. min 이 {2})